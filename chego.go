// Package chego (chess in go) implements chess logic.
package chego

import (
	"chego/enum"
	"math/rand/v2"
)

// Move represents a chess move, encoded as a 16 bit unsigned integer:
//
//	0-5: To (destination) square index;
//	6-11: From (origin/source) square index;
//	12-13: Promotion piece (00 - knight, 01 - bishop, 10 - rook, 11 - queen);
//	14-15: Move type (see [enum.MoveType]).
type Move uint16

func NewMove(to, from, promotionPiece, moveType int) Move {
	return Move(to | (from << 6) | (promotionPiece << 12) | (moveType << 14))
}
func (m Move) To() int                    { return int(m & 0x3F) }
func (m Move) From() int                  { return int(m>>6) & 0x3F }
func (m Move) PromotionPiece() enum.Piece { return enum.Piece(m>>12) & 0x3 }
func (m Move) Type() enum.MoveType        { return enum.MoveType(m>>14) & 0x3 }

const (
	// Precalculated magic used to form a keys for the BitScanLookup associative array.
	BITSCAN_MAGIC uint64 = 0x07EDD5E59A4E28C2
	// The following constants are used to prevent a bitboard overflow during move generation.
	// Bitmask of all files except the A.
	NOT_A_FILE uint64 = 0xFEFEFEFEFEFEFEFE
	// Bitmask of all files except the H.
	NOT_H_FILE uint64 = 0x7F7F7F7F7F7F7F7F
	// Bitmask of all files except the A and B.
	NOT_AB_FILE uint64 = 0xFCFCFCFCFCFCFCFC
	// Bitmask of all files except the G and H.
	NOT_GH_FILE uint64 = 0x3F3F3F3F3F3F3F3F
	// Bitmask of all ranks except first.
	NOT_1ST_RANK uint64 = 0xFFFFFFFFFFFFFF00
	// Bitmask of all ranks except eighth.
	NOT_8TH_RANK uint64 = 0x00FFFFFFFFFFFFFF
)

// BitScan returns the index of the Least Significant Bit (LSB) withing a bitboard.
// bitboard&-bitboard is the LSB which is then run through the hashing scheme to index a lookup.
func BitScan(bitboard uint64) int { return BitScanLookup[bitboard&-bitboard*BITSCAN_MAGIC>>58] }

// PopLSB pops the Least Significant Bit from a bitboard.
func PopLSB(bitboard *uint64) int {
	lsb := BitScan(*bitboard)
	*bitboard &= *bitboard - 1
	return lsb
}

// CountBits returns the number of bits set on the bitboard.
func CountBits(bitboard uint64) int {
	var cnt int
	for bitboard > 0 {
		cnt++
		bitboard &= bitboard - 1
	}
	return cnt
}

// PseudoRandUint64FewBits returns a pseudo-random uint64 with a few set bits.
func PseudoRandUint64FewBits() uint64 { return rand.Uint64() & rand.Uint64() & rand.Uint64() }

var (
	// Precalculated lookup table of LSB indices for 64 uints.
	// See http://pradu.us/old/Nov27_2008/Buzz/research/magic/Bitboards.pdf section 3.2
	BitScanLookup = [64]int{
		63, 0, 58, 1, 59, 47, 53, 2,
		60, 39, 48, 27, 54, 33, 42, 3,
		61, 51, 37, 40, 49, 18, 28, 20,
		55, 30, 34, 11, 43, 14, 22, 4,
		62, 57, 46, 52, 38, 26, 32, 41,
		50, 36, 17, 19, 29, 10, 13, 21,
		56, 45, 25, 31, 35, 16, 9, 12,
		44, 24, 15, 8, 23, 7, 6, 5,
	}
	// Precalculated lookup table of magic numbers for a bishop.
	// Generated by the GenMagicNumber function.
	MagicBishopLookup = [64]uint64{
		0x92008001040100,
		0x8215244000000200,
		0x1009000002800001,
		0x102202a0440020,
		0x100070001000021,
		0x100300d024080220,
		0xa042600000412046,
		0x1020002201046000,
		0x8100008304440001,
		0x29100511200105,
		0x2000c5000020181,
		0x60881100412000,
		0x250005608000008,
		0x50224020242140,
		0x4042001a0230400,
		0x200008206c03820a,
		0x41280080010a040,
		0x683804040628218,
		0x4308001260028020,
		0x8000001c0600000,
		0x2054108a041802c0,
		0x210008a01e007000,
		0x500420a8010,
		0xc040108100111000,
		0x290264204020800,
		0x20442202a00108a8,
		0x244804004019120,
		0x2400004a0c001000,
		0x200020100003014,
		0x40080300001,
		0x8031410008084,
		0x11201012000c0,
		0x4388000286053c00,
		0x1001800000418834,
		0xc004120110000408,
		0x820000c00022100,
		0x2100000048d04080,
		0x1000008801601,
		0x2001080900400460,
		0x18400220400600c,
		0x9490a040100000,
		0x160001a80,
		0xa070088045080480,
		0x2000400000522,
		0x8200080042a03,
		0x414012000846805,
		0x1898010000182084,
		0x9022020004204,
		0x4c80908068010010,
		0xc240301601100200,
		0x4849000c0600008,
		0x4800000230042240,
		0x9000044408580000,
		0x80020022800,
		0x24b016002000098,
		0x66000800136184,
		0x2018900001308208,
		0xa000a0000068231,
		0x120000000240024c,
		0x34304000282000,
		0x4c00008220580,
		0x10480000004c8,
		0x1800080009880104,
		0x84a6000000011800,
	}
	// Precalculated lookup table of magic numbers for a rook.
	// Generated by the GenMagicNumber function.
	MagicRookLookup = [64]uint64{
		0x910002205122000,
		0x90288a2000010221,
		0x270025130000110,
		0x8080003000080000,
		0xa0221008900080,
		0x10420480000001,
		0x83001c4010008800,
		0x40b000410000c808,
		0xc010818000108600,
		0x10104006050000,
		0x10800c080008002,
		0x6d00202880009052,
		0x1028082020200,
		0x9218000000000910,
		0x400200000201b8,
		0x42008808240210,
		0xc08008020000400,
		0xc010002000000000,
		0x8070000020012,
		0x4000200080410004,
		0x61408004040141,
		0x140000000300b0,
		0x100040000080000,
		0x22145a000200010,
		0x8022000010804000,
		0x4000200008045010,
		0x4040000040160020,
		0x40000044810280,
		0x14a024008000a8,
		0x20810108010004e0,
		0xc800008040004000,
		0x8000201a02041200,
		0x2001050080040,
		0x88814000c48000,
		0x80320400008128,
		0x90230102020c00,
		0x8010000100d01148,
		0x385a0042084,
		0x7880090085014049,
		0x2802040420300004,
		0x204007090080080,
		0x200aa08104044440,
		0x800004a100004080,
		0x20c400000006200,
		0x6004104140804020,
		0x1080058400820,
		0x240880820088800,
		0x2000900420400109,
		0x1a41006302000030,
		0x9102000020aa000,
		0xc0008200041220c,
		0x220860088008005,
		0x9c006802500104,
		0xe800c21000040008,
		0x10110000122a804,
		0xa001001288000020,
		0x22050000844000,
		0x2c000000610008,
		0x40808000807004,
		0x4400a404000401,
		0x16104208,
		0x4004000202001002,
		0x8000304,
		0x1000800000105,
	}
	// Precalculated attack tables used to speed up the move generation process.
	// Pawn's attack pattern depends on the color, so it is necessary to store two tables.
	PawnAttacks             [2][64]uint64
	KnightAttacks           [64]uint64
	KingAttacks             [64]uint64
	BishopRelevantOccupancy [64]uint64
	RookRelevantOccupancy   [64]uint64
	// Precalculated lookup table of bishop relevant occupancy bit count for every square.
	BishopRelevantOccupancyBitCount = [64]int{
		6, 5, 5, 5, 5, 5, 5, 6,
		5, 5, 5, 5, 5, 5, 5, 5,
		5, 5, 7, 7, 7, 7, 5, 5,
		5, 5, 7, 9, 9, 7, 5, 5,
		5, 5, 7, 9, 9, 7, 5, 5,
		5, 5, 7, 7, 7, 7, 5, 5,
		5, 5, 5, 5, 5, 5, 5, 5,
		6, 5, 5, 5, 5, 5, 5, 6,
	}
	// Precalculated lookup table of rook relevant occupancy bit count for every square.
	RookRelevantOccupancyBitCount = [64]int{
		12, 11, 11, 11, 11, 11, 11, 12,
		11, 10, 10, 10, 10, 10, 10, 11,
		11, 10, 10, 10, 10, 10, 10, 11,
		11, 10, 10, 10, 10, 10, 10, 11,
		11, 10, 10, 10, 10, 10, 10, 11,
		11, 10, 10, 10, 10, 10, 10, 11,
		11, 10, 10, 10, 10, 10, 10, 11,
		12, 11, 11, 11, 11, 11, 11, 12,
	}
)

// GenPawnAttacks returns a bitboard of squares attacked by a pawn.
func GenPawnAttacks(pawn uint64, color enum.Color) uint64 {
	if color == enum.ColorWhite {
		return (pawn & NOT_A_FILE << 7) | (pawn & NOT_H_FILE << 9)
	}
	// Handle black pawns.
	return (pawn & NOT_A_FILE >> 9) | (pawn & NOT_H_FILE >> 7)
}

// GenKnightAttacks returns a bitboard of squares attacked by a knight.
func GenKnightAttacks(knight uint64) uint64 {
	return (knight & NOT_A_FILE >> 17) |
		(knight & NOT_H_FILE >> 15) |
		(knight & NOT_AB_FILE >> 10) |
		(knight & NOT_GH_FILE >> 6) |
		(knight & NOT_AB_FILE << 6) |
		(knight & NOT_GH_FILE << 10) |
		(knight & NOT_A_FILE << 15) |
		(knight & NOT_H_FILE << 17)
}

// GenKingAttacks returns a bitboard of squares attacked by a king.
func GenKingAttacks(king uint64) uint64 {
	return (king & NOT_A_FILE >> 9) |
		(king >> 8) |
		(king & NOT_H_FILE >> 7) |
		(king & NOT_A_FILE >> 1) |
		(king & NOT_H_FILE << 1) |
		(king & NOT_A_FILE << 7) |
		(king << 8) |
		(king & NOT_H_FILE << 9)
}

// GenBishopAttacks returns a bitboard of squares attacked by a bishop.
// Occupied squares that block movement in each direction are taken into account.
// The resulting bitboard includes the occupied squares.
func GenBishopAttacks(bishop uint64, occupancy uint64) uint64 {
	var attacks uint64

	for i := bishop & NOT_A_FILE >> 9; i&NOT_H_FILE != 0; i >>= 9 {
		attacks |= i
		if i&occupancy != 0 {
			break
		}
	}

	for i := bishop & NOT_H_FILE >> 7; i&NOT_A_FILE != 0; i >>= 7 {
		attacks |= i
		if i&occupancy != 0 {
			break
		}
	}

	for i := bishop & NOT_A_FILE << 7; i&NOT_H_FILE != 0; i <<= 7 {
		attacks |= i
		if i&occupancy != 0 {
			break
		}
	}

	for i := bishop & NOT_H_FILE << 9; i&NOT_A_FILE != 0; i <<= 9 {
		attacks |= i
		if i&occupancy != 0 {
			break
		}
	}

	return attacks
}

// GenRookAttacks returns a bitboard of squares attacked by a rook.
// Occupied squares that block movement in each direction are taken into account.
// The resulting bitboard includes the occupied squares.
func GenRookAttacks(rook uint64, occupancy uint64) uint64 {
	var attacks uint64

	for i := rook & NOT_A_FILE >> 1; i&NOT_H_FILE != 0; i >>= 1 {
		attacks |= i
		if i&occupancy != 0 {
			break
		}
	}

	for i := rook & NOT_H_FILE << 1; i&NOT_A_FILE != 0; i <<= 1 {
		attacks |= i
		if i&occupancy != 0 {
			break
		}
	}

	for i := rook & NOT_1ST_RANK >> 8; i&NOT_8TH_RANK != 0; i >>= 8 {
		attacks |= i
		if i&occupancy != 0 {
			break
		}
	}

	for i := rook & NOT_8TH_RANK << 8; i&NOT_1ST_RANK != 0; i <<= 8 {
		attacks |= i
		if i&occupancy != 0 {
			break
		}
	}

	return attacks
}

// InitBishopRelevantOccupancy initializes the lookup table of the "relevant occupancy squares" for a bishop.
// They are the only squares whose occupancy matters when generating the legal moves of a bishop.
// This function is used to initialize a predefined array of bishop attacks using magic bitboards.
func InitBishopRelevantOccupancy() {
	// Helper constants.
	not_A_not_1st := NOT_A_FILE & NOT_1ST_RANK
	not_H_not_1st := NOT_H_FILE & NOT_1ST_RANK
	not_A_not_8th := NOT_A_FILE & NOT_8TH_RANK
	not_H_not_8th := NOT_H_FILE & NOT_8TH_RANK

	for square := 0; square < 64; square++ {
		var occupancy, bishop uint64 = 0, 1 << square

		for i := bishop & NOT_A_FILE >> 9; i&not_A_not_1st != 0; i >>= 9 {
			occupancy |= i
		}

		for i := bishop & NOT_H_FILE >> 7; i&not_H_not_1st != 0; i >>= 7 {
			occupancy |= i
		}

		for i := bishop & NOT_A_FILE << 7; i&not_A_not_8th != 0; i <<= 7 {
			occupancy |= i
		}

		for i := bishop & NOT_H_FILE << 9; i&not_H_not_8th != 0; i <<= 9 {
			occupancy |= i
		}

		BishopRelevantOccupancy[square] = occupancy
	}
}

// InitRookRelevantOccupancy initializes the lookup table of the "relevant occupancy squares" for a rook.
// They are the only squares whose occupancy matters when generating the legal moves of a rook.
// This function is used to initialize a predefined array of rook attacks using magic bitboards.
func InitRookRelevantOccupancy() {
	for square := 0; square < 64; square++ {
		var occupancy, rook uint64 = 0, 1 << square

		for i := rook & NOT_1ST_RANK >> 8; i&NOT_1ST_RANK != 0; i >>= 8 {
			occupancy |= i
		}

		for i := rook & NOT_A_FILE >> 1; i&NOT_A_FILE != 0; i >>= 1 {
			occupancy |= i
		}

		for i := rook & NOT_H_FILE << 1; i&NOT_H_FILE != 0; i <<= 1 {
			occupancy |= i
		}

		for i := rook & NOT_8TH_RANK << 8; i&NOT_8TH_RANK != 0; i <<= 8 {
			occupancy |= i
		}

		RookRelevantOccupancy[square] = occupancy
	}
}

// GenOccupancies returns a bitboard of blocker pieces for the specified attack bitboard.
//
//	key <= (2^relevantBitsCount) - 1
//	relevantBitsCount = (Rook | Bishop)RelevantOccupancyBitCount[square]
//	relevantOccupancy = (Rook | Bishop)RelevantOccupancy[square]
func GenOccupancies(key, relevantBitCount int, relevantOccupancy uint64) uint64 {
	var occupancy uint64

	for i := 0; i < relevantBitCount; i++ {
		square := PopLSB(&relevantOccupancy)

		if key&(1<<square) != 0 {
			occupancy |= 1 << square
		}
	}

	return occupancy
}

// GenMagicNumber returns a magic number used to hash the sliding piece's possible moves.
// See https://www.chessprogramming.org/Looking_for_Magics
func GenMagicNumber(square int, isBishop bool) uint64 {
	var occupancies, attacks [4096]uint64

	var attack uint64
	var relevantBitCount int
	if isBishop {
		attack = BishopRelevantOccupancy[square]
		relevantBitCount = BishopRelevantOccupancyBitCount[square]
	} else {
		attack = RookRelevantOccupancy[square]
		relevantBitCount = RookRelevantOccupancyBitCount[square]
	}

	for i := 0; i < 1<<relevantBitCount; i++ {
		occupancies[i] = GenOccupancies(i, relevantBitCount, attack)

		if isBishop {
			attacks[i] = GenBishopAttacks(1<<square, occupancies[i])
		} else {
			attacks[i] = GenRookAttacks(1<<square, occupancies[i])
		}
	}

	for i := 0; i < 100000000; i++ {
		magicNumber := PseudoRandUint64FewBits()

		if CountBits(attack*magicNumber&0xFF00000000000000) < 6 {
			continue
		}

		var taken [4096]uint64
		var j, fail int

		for ; j < 1<<relevantBitCount; j++ {
			// Form a magic hash key.
			magicKey := int(occupancies[j] * magicNumber >> (64 - relevantBitCount))

			if taken[magicKey] == 0 {
				taken[magicKey] = attacks[j]
			} else if taken[magicKey] != attacks[j] {
				fail = 1
				break
			}
		}

		if fail == 0 {
			return magicNumber
		}
	}

	panic("failed to generate magic number")
}

// InitAttackTables initializes the predefined attack tables.
func InitAttackTables() {
	for square := 0; square < 64; square++ {
		PawnAttacks[enum.ColorWhite][square] = GenPawnAttacks(1<<square, enum.ColorWhite)
		PawnAttacks[enum.ColorBlack][square] = GenPawnAttacks(1<<square, enum.ColorBlack)

		KnightAttacks[square] = GenKnightAttacks(1 << square)

		KingAttacks[square] = GenKingAttacks(1 << square)
	}
}
