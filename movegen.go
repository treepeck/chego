// movegen.go implements move generation using Magic Bitboards approach.
//
// NOTE: Don't change the order of generated moves.  The [huffmanCodes] are
// tightly coupled to the indices of legal moves, generated by the concrete move generator.

package chego

const (
	// Bitmask of all files except the A.
	notAFile uint64 = 0xFEFEFEFEFEFEFEFE
	// Bitmask of all files except the H.
	notHFile uint64 = 0x7F7F7F7F7F7F7F7F
	// Bitmask of all files except the A and B.
	notABFile uint64 = 0xFCFCFCFCFCFCFCFC
	// Bitmask of all files except the G and H.
	notGHFile uint64 = 0x3F3F3F3F3F3F3F3F
	// Bitmask of all ranks except first.
	not1stRank uint64 = 0xFFFFFFFFFFFFFF00
	// Bitmask of all ranks except eighth.
	not8thRank uint64 = 0x00FFFFFFFFFFFFFF
	// Bitmask of the first rank.
	rank1 uint64 = 0xFF
	// Bitmask of the second rank.
	rank2 uint64 = 0xFF00
	// Bitmask of the seventh rank.
	rank7 uint64 = 0xFF000000000000
	// Bitmask of the eighth rank.
	rank8 uint64 = 0xFF00000000000000
)

// Move represents a chess move, encoded as a 16 bit unsigned integer:
//   - 0-5:   To (destination) square index.
//   - 6-11:  From (origin/source) square index.
//   - 12-13: Promotion piece (see [PromotionFlag]).
//   - 14-15: Move type (see [MoveType]).
type Move uint16

// NewMove creates a new move with the promotion piece set to [PromotionQueen].
func NewMove(to, from, moveType int) Move {
	return Move(to | (from << 6) | (PromotionQueen << 12) | (moveType << 14))
}

// NewPromotionMove creates a new move with the promotion type and specified
// promotion piece.
func NewPromotionMove(to, from, promoPiece int) Move {
	return Move(to | (from << 6) | (promoPiece << 12) | (MovePromotion << 14))
}

func (m Move) To() int                   { return int(m & 0x3F) }
func (m Move) From() int                 { return int(m>>6) & 0x3F }
func (m Move) PromoPiece() PromotionFlag { return PromotionFlag(m>>12) & 0x3 }
func (m Move) Type() MoveType            { return MoveType(m>>14) & 0x3 }

// MoveList is used to store moves.  The main idea behind it is to preallocate
// an array with enough capacity to store all possible moves and avoid dynamic
// memory allocations.
type MoveList struct {
	// Maximum number of moves per chess position is equal to 218,
	// hence 218 elements.
	// See https://www.talkchess.com/forum/viewtopic.php?t=61792
	Moves [218]Move
	// To keep track of the next move index.
	LastMoveIndex byte
}

// Push adds the move to the end of the move list.
func (l *MoveList) Push(m Move) {
	l.Moves[l.LastMoveIndex] = m
	l.LastMoveIndex++
}

// GenLegalMoves generates legal moves for the given position using copy-make
// approach.
func GenLegalMoves(p Position, l *MoveList) {
	l.LastMoveIndex = 0

	genKingMoves(p, l)

	if GenChecksCounter(p.Bitboards, 1^p.ActiveColor) > 2 {
		return
	}

	pseudoLegal := MoveList{}

	genPawnMoves(p, &pseudoLegal)

	genNormalMoves(p, &pseudoLegal)

	prev := p
	var moved, captured Piece

	for i := range pseudoLegal.LastMoveIndex {
		moved = p.GetPieceFromSquare(1 << pseudoLegal.Moves[i].From())
		captured = p.GetPieceFromSquare(1 << pseudoLegal.Moves[i].To())

		p.MakeMove(pseudoLegal.Moves[i], moved, captured)

		if GenChecksCounter(p.Bitboards, p.ActiveColor) == 0 {
			l.Push(pseudoLegal.Moves[i])
		}

		p = prev
	}
}

// GenChecksCounter returns the number of the pieces of the specified color that
// are delivering a check to the enemy king.
func GenChecksCounter(bitboards [15]uint64, c Color) (cnt int) {
	king := bitScan(bitboards[WKing+(1^c)])

	if pawnAttacks[1^c][king]&bitboards[WPawn+c] != 0 {
		cnt++
	}

	if knightAttacks[king]&bitboards[WKnight+c] != 0 {
		cnt++
	}

	if lookupBishopAttacks(king, bitboards[14])&bitboards[WBishop+c] != 0 {
		cnt++
	}

	if lookupRookAttacks(king, bitboards[14])&bitboards[WRook+c] != 0 {
		cnt++
	}

	if lookupQueenAttacks(king, bitboards[14])&bitboards[WQueen+c] != 0 {
		cnt++
	}

	return cnt
}

// genKingMoves appends legal moves for the king on the given position to the
// specified move list.  Handles special king move - castling.
func genKingMoves(p Position, l *MoveList) {
	kingBB := p.Bitboards[WKing+p.ActiveColor]
	p.removePiece(WKing+p.ActiveColor, kingBB)
	attacks := genAttacks(p.Bitboards, 1^p.ActiveColor)
	p.removePiece(WKing+p.ActiveColor, kingBB)
	king := bitScan(kingBB)

	dests := kingAttacks[king] & (^attacks) & (^p.Bitboards[12+p.ActiveColor])

	for dests > 0 {
		l.Push(NewMove(popLSB(&dests), king, MoveNormal))
	}

	p.Bitboards[14] ^= kingBB
	// Handle castling.
	if p.ActiveColor == ColorWhite {
		if p.canCastle(CastlingWhiteShort, attacks, p.Bitboards[14]) &&
			p.Bitboards[WRook]&H1 != 0 {
			l.Push(NewMove(SG1, king, MoveCastling))
		}
		if p.canCastle(CastlingWhiteLong, attacks, p.Bitboards[14]) &&
			p.Bitboards[WRook]&A1 != 0 {
			l.Push(NewMove(SC1, king, MoveCastling))
		}
	} else {
		if p.canCastle(CastlingBlackShort, attacks, p.Bitboards[14]) &&
			p.Bitboards[BRook]&H8 != 0 {
			l.Push(NewMove(SG8, king, MoveCastling))
		}
		if p.canCastle(CastlingBlackLong, attacks, p.Bitboards[14]) &&
			p.Bitboards[BRook]&A8 != 0 {
			l.Push(NewMove(SC8, king, MoveCastling))
		}
	}
}

// genPawnMoves appends pseudo-legal moves for a pawns to the given move list.
// Handles special pawn move - en passant.
func genPawnMoves(p Position, l *MoveList) {
	occupancy := p.Bitboards[14]
	ep := uint64(0)
	if p.EPTarget > 0 {
		ep = 1 << p.EPTarget
	}
	enemies := p.Bitboards[12+(1^p.ActiveColor)]
	pawns := p.Bitboards[WPawn+p.ActiveColor]

	// Determine movement direction.
	dir, initRank, promoRank := 8, rank2, rank8
	if p.ActiveColor == ColorBlack {
		dir = -8
		initRank = rank7
		promoRank = rank1
	}

	for pawns > 0 {
		pawn := popLSB(&pawns)
		square := uint64(1 << pawn)

		fwd, dblFwd := pawn+dir, pawn+2*dir
		// If the pawn can move forward.
		fwdBB := uint64(1 << fwd)
		if fwdBB&occupancy == 0 {
			// Check if the move is promotion.
			if fwdBB&promoRank != 0 {
				l.Push(NewPromotionMove(fwd, pawn, PromotionKnight))
				l.Push(NewPromotionMove(fwd, pawn, PromotionBishop))
				l.Push(NewPromotionMove(fwd, pawn, PromotionRook))
				l.Push(NewPromotionMove(fwd, pawn, PromotionQueen))
			} else {
				l.Push(NewMove(fwd, pawn, MoveNormal))
			}
			// If the pawn is standing on its initial rank and can move
			// double forward.
			if square&initRank != 0 && 1<<dblFwd&occupancy == 0 {
				l.Push(NewMove(dblFwd, pawn, MoveNormal))
			}
		}

		// Handle pawn attacks.  Pawn can only capture enemy pieces
		// or the en passant target square.
		attacks := pawnAttacks[p.ActiveColor][pawn] & (enemies | ep)
		for attacks > 0 {
			to := popLSB(&attacks)
			// Handle capture promotion.
			if 1<<to&promoRank != 0 {
				l.Push(NewPromotionMove(to, pawn, PromotionKnight))
				l.Push(NewPromotionMove(to, pawn, PromotionBishop))
				l.Push(NewPromotionMove(to, pawn, PromotionRook))
				l.Push(NewPromotionMove(to, pawn, PromotionQueen))
			} else if 1<<to&ep != 0 {
				l.Push(NewMove(to, pawn, MoveEnPassant))
			} else {
				l.Push(NewMove(to, pawn, MoveNormal))
			}
		}
	}
}

// genPawnMoves appends pseudo-legal moves for knights, bishops, rooks, and
// queens to the given move list.
func genNormalMoves(p Position, l *MoveList) {
	c := p.ActiveColor
	allies := p.Bitboards[12+c]
	occupancy := p.Bitboards[14]

	for i := WKnight + c; i <= WQueen+c; i += 2 {
		pieces := p.Bitboards[i]
		for pieces > 0 {
			from := popLSB(&pieces)

			dests := uint64(0)
			switch i {
			case WKnight, BKnight:
				dests |= knightAttacks[from]
			case WBishop, BBishop:
				dests |= lookupBishopAttacks(from, occupancy)
			case WRook, BRook:
				dests |= lookupRookAttacks(from, occupancy)
			case WQueen, BQueen:
				dests |= lookupQueenAttacks(from, occupancy)
			}

			dests &= ^allies
			for dests > 0 {
				l.Push(NewMove(popLSB(&dests), from, MoveNormal))
			}
		}
	}
}

// genAttacks generates the bitboard of squares attacked by pieces of the specified
// color.  The main purpose of this function is to generate a bitboard of squares
// to which the king is forbidden to move.
//
// NOTE: The king must be excluded from the occupancy (bitboards[14]) bitboard to
// avoid blocking the attacks of slider pieces.  Otherwise, the king may appear to
// be able to move into check.
func genAttacks(bitboards [15]uint64, c Color) (attacks uint64) {
	for i := WBishop + c; i <= WQueen+c; i += 2 {
		bitboard := bitboards[i]
		for bitboard > 0 {
			slider := popLSB(&bitboard)

			switch i {
			case WBishop, BBishop:
				attacks |= lookupBishopAttacks(slider, bitboards[14])
			case WRook, BRook:
				attacks |= lookupRookAttacks(slider, bitboards[14])
			case WQueen, BQueen:
				attacks |= lookupQueenAttacks(slider, bitboards[14])
			}
		}
	}

	//  Exclude empty squares and squares occupied by allied pieces.
	attacks |= genPawnAttacks(bitboards[WPawn+c], c)
	// Exclude squares occupied by allied pieces.
	attacks |= genKnightAttacks(bitboards[WKnight+c])
	//  Exclude squares occupied by allied pieces.
	attacks |= genKingAttacks(bitboards[WKing+c])

	return attacks
}

// genPawnAttacks returns a bitboard of squares attacked by pawns.
//
// Use this function only to generate attacks for multiple pawns simultaneously.
// To get attacks for a single pawn, use the pawnAttacks lookup table.
func genPawnAttacks(pawn uint64, color Color) uint64 {
	if color == ColorWhite {
		return (pawn & notAFile << 7) | (pawn & notHFile << 9)
	}
	// Handle black pawns.
	return (pawn & notAFile >> 9) | (pawn & notHFile >> 7)
}

// genKnightAttacks returns a bitboard of squares attacked by knights.
//
// Use this function only to generate attacks for multiple knights simultaneously.
// To get attacks for a single knight, use the knightAttacks lookup table.
func genKnightAttacks(knight uint64) uint64 {
	return (knight & notAFile >> 17) |
		(knight & notHFile >> 15) |
		(knight & notABFile >> 10) |
		(knight & notGHFile >> 6) |
		(knight & notABFile << 6) |
		(knight & notGHFile << 10) |
		(knight & notAFile << 15) |
		(knight & notHFile << 17)
}

// genKingAttacks returns a bitboard of squares attacked by a king.
func genKingAttacks(king uint64) uint64 {
	return (king & notAFile >> 9) |
		(king >> 8) |
		(king & notHFile >> 7) |
		(king & notAFile >> 1) |
		(king & notHFile << 1) |
		(king & notAFile << 7) |
		(king << 8) |
		(king & notHFile << 9)
}

// genBishopAttacks returns a bitboard of squares attacked by a bishop.
//
// Occupied squares that block movement in each direction are taken into account.
// The resulting bitboard includes the occupied squares.  This function cannot
// generate attacks for multiple bishops simultaneously.
func genBishopAttacks(bishop, occupancy uint64) (attacks uint64) {
	for i := bishop & notAFile >> 9; i&notHFile != 0; i >>= 9 {
		attacks |= i
		if i&occupancy != 0 {
			break
		}
	}

	for i := bishop & notHFile >> 7; i&notAFile != 0; i >>= 7 {
		attacks |= i
		if i&occupancy != 0 {
			break
		}
	}

	for i := bishop & notAFile << 7; i&notHFile != 0; i <<= 7 {
		attacks |= i
		if i&occupancy != 0 {
			break
		}
	}

	for i := bishop & notHFile << 9; i&notAFile != 0; i <<= 9 {
		attacks |= i
		if i&occupancy != 0 {
			break
		}
	}

	return attacks
}

// genRookAttacks returns a bitboard of squares attacked by a rook.
//
// Occupied squares that block movement in each direction are taken into account.
// The resulting bitboard includes the occupied squares.  This function cannot
// generate attacks for multiple rooks simultaneously.
func genRookAttacks(rook, occupancy uint64) (attacks uint64) {
	for i := rook & notAFile >> 1; i&notHFile != 0; i >>= 1 {
		attacks |= i
		if i&occupancy != 0 {
			break
		}
	}

	for i := rook & notHFile << 1; i&notAFile != 0; i <<= 1 {
		attacks |= i
		if i&occupancy != 0 {
			break
		}
	}

	for i := rook & not1stRank >> 8; i&not8thRank != 0; i >>= 8 {
		attacks |= i
		if i&occupancy != 0 {
			break
		}
	}

	for i := rook & not8thRank << 8; i&not1stRank != 0; i <<= 8 {
		attacks |= i
		if i&occupancy != 0 {
			break
		}
	}

	return attacks
}

// lookupBishopAttacks returns a bitboard of squares attacked by a bishop.  The
// bitboard is taken from the bishopAttacks using magic hashing scheme.
func lookupBishopAttacks(square int, occupancy uint64) uint64 {
	occupancy &= bishopOccupancy[square]
	occupancy *= bishopMagicNumbers[square]
	occupancy >>= 64 - bishopBitCount[square]
	return bishopAttacks[square][occupancy]
}

// lookupRookAttacks returns a bitboard of squares attacked by a rook.  The
// bitboard is taken from the rookAttacks using magic hashing scheme.
func lookupRookAttacks(square int, occupancy uint64) uint64 {
	occupancy &= rookOccupancy[square]
	occupancy *= rookMagicNumbers[square]
	occupancy >>= 64 - rookBitCount[square]
	return rookAttacks[square][occupancy]
}

// lookupQueenAttacks returns a bitboard of squares attacked by a queen.  The
// bitboard is calculated as the logical disjunction of the bishop and rook attack
// bitboards.
func lookupQueenAttacks(square int, occupancy uint64) uint64 {
	return lookupBishopAttacks(square, occupancy) |
		lookupRookAttacks(square, occupancy)
}
